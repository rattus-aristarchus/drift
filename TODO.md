# ФУНКЦИОНАЛЬНОСТЬ

# юай
_мордочка_

- сделать выбор иконок из массива спрайтов а не отдельными файлами

# ио
_чтение/запись с диска_

- модели раньше использовались как абстрактные "неизменяемые" значения; сделать для таких 
значений тупо словарь словарей констант
- добавить возможность прописывать "pops" и "groups" в csv-файле карты.
(хз насколько важно если карты будут генерируемыми)
- нужно сделать так, чтобы загружены в factory были только модели из определенной папки; 
или создавать отдельную factory для каждой папки. иначе будет проблема с одинаковыми именами
entities. плюс надо где-то добавить указание, что имена entities должны быть уникальными для 
каждой папки

# логика
_все что относится к структуре приложения_

- recurrent.last_copy. как же это достало. постоянные ошибки из-за того, что забыл, что 
чтение только из прошлого хода, а запись только в текущий. надо как-то это автоматизировать;
но если сделать какую-нибудь черную магию чтобы всё чтение автоматически шло через last_copy, 
это не питоник, типо не эксплицитно. надо тут чото придумать. 
- подумать о том, как сделать эффекты менее привязанными к основному коду
- если resources является частью cell, то и capacity должна тоже; вообще, должен быть один 
механизм для того и другого, сейчас разброд и шатание какое-то. по-хорошему, наверное 
сколько ресурсов стартово в каждом биоме должно храниться отдельной константой где-то, а не 
в biome. отдельная система инструкций для создания клеток - столько то ресурсов, столько то
популяций. м/б объединить это с populate instructions в populate_history
- непоследовательные механизмы для создания новых world, history, grid и cell
- rules. проблема. по большому счету все, что есть в yaml-файлах - это вещи, которые не должны 
изменяться по ходу симуляции. пока что не будем создавать rules как абстрактные прототипы,
и все, даже неизменяемые, параметры будем держать тупо в сущностях. rules оставим в отдельной 
ветке rules (если вдруг захотим к ним вернуться)
- надо подумать, где у нас правильнее держать эффекты, и должно ли быть столько разных 
наследников agents
- для need добавить параметр weight, чтобы определять общую удовлетворенность / 
неудовлетворенность
- копирование recurrents. при копировании grid приходится вызывать отдельный метод on_copy 
и копировать через него - потому что копирование сейчас поддерживается для словарей и списков,
а в grid cells - это словарь словарей. надо встроить это как-то по-умному в общий алгоритм и 
удалить on_copy из grid; и добавить вызов общего копирования, не возвращающий all_recurrents,
чтобы легче и без вопросов можно было копировать систему в целом.

## проблемы с порядком вычислений
возможно, здесь потребуется придумать общее решение.
может, создать новый класс, эдакий "вычислительный центр", экземпляр которого будет "над" 
каждой клеткой; туда перенести draw, barrier, всякие промежуточные результаты вычислений; 
всё, что раньше выполнял cell_buffer. и вот он будет управлять порядком вычислений. 
ну и по логике создать аналогичный "вычислительный центр" для grid. 

- когда создается новая популяция, ее потребности будут рассчитаны только 
на следующем ходу - либо надо вручную вызывать расчет потребностей 
- какой-то гемор был с рынками


## рефакторинг ресурсов
- попробовать нахрен переписать ресурсы - не как отдельный класс, а как 
учетную книгу в Cell, в которой хранятся записи тип - владелец - количество. или 
по крайней мере создавать новый ресурс для каждого владельца. ЗА: один источник правды,
не нужно следить чтобы сумма по собственникам равнялась общему количеству ресурса. ПРОТИВ:
- или пойти в противоположную сторону и сделать так, чтобы все ресурсы были ТОЛЬКО у 
популяции, а cell.resources была @property и просто собирала список ресурсов с популяций. 
хотя тогда как хранить бесхозные ресурсы? 
- или просто сделать собственность отдельным модулем - сейчас так и так все функции, 
связанные с собственностью, болтаются в agents отдельно и от ресурсов, и от популяций. 
оставить и ресурсы, и популяции в cell, и добавить эту несчастную учетную книгу которая будет
сопоставлять одно с другим. вот это наверное самое правильное будет.
- и однозначно надо навести порядок в функциях ownership в agents - сейчас разницы между 
set ownership и add ownership почти нет


# модели
_что мы, собственно, моделируем. то, что лежит в файлах yaml и effects_

- смена биомов в клетке. сюжет: нижнее течение хуанхэ было всю дорогу 
болотами, и только уже в 1 тыс до р х люди превратили ее в равнины; до
этого жили на полуострове шаньдун, жили в среднем течении хуанхэ, а посередине 
были болота
- колебания температуры. сейчас идут просто по синусоиде; надо к этому добавить
случайную составляющую

- какая у нас проблема с рынком? на рынке обменивается излишек на - все остальное; 
когда только только появляются ремесла, они будут "собирать" оч много излишка; 
значит, нужен более умный механизм превращения в ремесленников; делаем переменную 
draw (или attraction), которая может зависеть от разных вещей, одна из них - прибыльность 
ремесла; и этот draw определяет сколько людей становятся этим сообществом. кроме того, 
нужна переменная barrier - барьер для соц. лифтов, которая будет отниматься от draw 
(или на нее делить draw). дальше в этот механизм встраиваем миграции - для каждой популяции
каждый ход будет список возможных других популяций, к которым её "притягивает" - как в своей
клетке, так и в соседних; правда, для моделей наверное удобнее хранить список популяций, ИЗ
которых эту популяцию можно пополнить
- как быть с миграциями на дальние расстояния? непосредственные производители могут 
мигрировать из клетки в клетку, но от одного месторождения руды к другому так не пойдет, ну и 
потом для миграции из города в город тоже хорошо было бы иметь механизм. добавляем новый вид
сущности - знание; у каждой популяции как список ресурсов, так и список знаний; как и популяции,
знания мигрируют. подвид - слухи о местах; и соответственно при решении о миграции в списке 
возможных целей добавляются не только соседние клетки, но и места из слухов. 


## бронзовый век

потребуется:
- механизм миграций
- дальняя торговля
- государства; возникают при достаточной производительности хозяйства и опр. 
численности населения. 

# БАГИ

- если запустить симуляцию surplus_and_craft и после первой экспансии начать прокручивать 
назад, только что созданные популяции никак не меняются
- стопудово будут баги когда удалится какая-нибудь сущность (напр. потому что
ее численность упала до нуля) и все ссылки .next_copy либо упадут, либо, еще хуже, 
буду указывать на удаленную из клетки но не из памяти сущность 
- в юае карта урезана справа (если недостаточно широко открыто окно) и слишком длинная внизу
- когда популяция умирает, происходит что-то странное - в первый ход когда ее нет 
по-прежнему на юае можно прочитать ее численность (отрицательную), и у ресурсов она 
указана собственником. 